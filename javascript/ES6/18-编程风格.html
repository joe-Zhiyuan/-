<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ES6-18-编程风格</title>
</head>
<body>

</body>
</html>
<script type="module">
    // let取代var
    'use strict';
    for(let i = 0; i < 10; i++){
        setTimeout(() => {console.log(i)},100);//0-9
    }
    for(var i = 0; i < 10; i++){
        setTimeout(() => {console.log(i)},100);//10 *10
    }

    // 全局变量与线程安全  常量  const   有利于线程安全
    // 1.const变量值不会改变
    // 2.运算不会改变值，只有新建值
    // 3.使用const有利于程序的运行效率
    const A = 1;

    // 字符串  一律使用单引号 或 反引号  不使用双引号  动态字符串使用反引号
    const B = 'qiao';
    let c = `joe`;

    // 解构赋值  优先使用解构赋值       函数返回多个值 有限使用对象的解构赋值  不是数组的解构赋值  有利于以后添加值和更改值的顺序
    const arr = [1,2,3,4];
    const [first, second] = arr;//数组
    function get(obj){
        const {name, age} = obj;//对象
    }

    // 对象
    // 单行定义 最后一个成员不宜逗号结尾  多行定义 最后一个成员以逗号结尾
    const a = {k1:'v1',k2:'v2'};
    const b = {
        k1:'v1',
        k2:'v2',
    };
    // 对象静态化  不得随意添加属性  添加属性要使用Object.assign()方法
    Object.assign(a, {x:3});
    // 对象的属性名是动态的  在创造对象时使用属性表达式定义   方法一样
    const obj = {
        id:5,
        name:"joe",
        // [getKey('qiao')]:true,
    };
    const atom = {
        // ref,
        value:1,
        addValue(value){
            return atom.value + value;
        },
    };

    // 数组  使用(...)来复制数组  使用Array.from方法将类似数组对象转化为数组
    const itemCopy = [...arr];
    const foo = document.querySelectorAll("body");
    const nodes = Array.from(foo);
    console.log(nodes);

    // 函数   立即执行函数写成箭头函数的形式  使用函数表达式的场合 使用箭头函数代替
    (() => {console.log('立即执行函数');})();
    [1,2,3].map((x) => {
        return x * x;
    });
    // const boundMethod = method.name(this);
    // 函数行数较多应该使用传统写法   所有配置项放到一个对象上 放在最后一个参数  布尔值不可直接作为参数
    function devide(a, b, {option = false} = {}){

    }
    // 不要在函数体内使用araguments变量  使用(...)代替   使用默认值时设置函数参数默认值
    function concatenateAll(...args){
        return args.join(',');
    }
    function handleThings(opts = {}){

    }

    // Map结构  区分Object和Map  模拟实体对象使用Object  只是需要 k:v结构 使用Map因为Map有遍历机制
    // let map = new Map(arr);
    // for(let key of map.keys()){
    //     console.log(key);
    // }
    // for(let value of map.values()){
    //     console.log(value);
    // }
    // for(let item of map.entries()){
    //     console.log(item);
    // }

    // Class 使用Class代替prototype操作  Class更简洁 易于理解
    class Queue{
        constructor(contents = []){
            this._queue = [...contents];
        }
        pop(){
            const value = this._queue[0];
            this._queue.splice(0, 1);
            return value;
        }
    }
    // 使用extends实现继承
    class peekableQueue extends Queue{
        peek(){
            return this._queue[0];
        }
    }

    // 模块  坚持标准写法   type="module"
    // 使用import代替require
    //使用export代替module.exports
    // 如果只有一个输出值 使用default默认输出  如果多个输出 不要同时使用export.default和export
    // 不要在模块输出中使用通配符    确保模块有一个默认输出
    // 模块输出一个函数函数名首字母小写
    // 输出对象首字母大写
    function getKey(){

    }
    export { getKey };
    const StyleColor = {

    };
    export { StyleColor };

    // ESLint使用  限制规则  检测代码 错误和风格

</script>
