<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ES6-2-变量解构赋值</title>
</head>
<body>

</body>
<script>
    //es5
    let a = 1;
    let b = 2;
    let c = 3;
    //es6
    let [d,e,f,g] = [1,2,3];
    console.log(g);//如果解构不成功 值为undefined
    console.log(b,d);//2 1
    let [ , , third1] = [1,2,3];
    console.log(third1);//3 一一对应
    let [head,...tail] = [1,2,3,4];
    console.log(tail);//2,3,4
    // let [foo] = 1;//error 不是可遍历结构
    //set结构也可以解构赋值
    let [x,y,z] = new Set(['a','b','c']);
    console.log(x);//a  只要具有Iterator接口，都可以采用数组形式的解构赋值
    function* fibs(){
        let a = 0;
        let b = 1;
        while(true){
            yield a;
            [a,b] = [b, a+b];
        }
    }
    let [first,second,third,fourth,fifth,sixth] = fibs();
    console.log(sixth);//5  0-5  依次加1  从这个接口获取值

    //默认值
    let [foo2 = true] = [];
    console.log(foo2);//true 默认值为true
    let [x1,y1='b'] = ['a'];
    console.log(x1,y1);//a b
    let [x2,y2='b'] = ['a',undefined];
    console.log(x2,y2);//a b 如果不严格等于===undefined 默认值不会生效
    let [x4 = 1] = [undefined];
    console.log(x4);//1
    let [x5 = 1] = [null];
    console.log(x5);//null 不生效
    //表达式也可以
    function fc(){
        console.log('aaa');
    }
    let [x6 = fc()] = [1];
    console.log(x6);//1
</script>
</html>